import os
import subprocess
import datetime
import sys
import threading
import time
import itertools

# ================= 配置区域 =================

# Keil UV4 可执行文件路径
# 请根据实际安装位置修改此路径
# 常见路径: 
# C:\Keil_v5\UV4\UV4.exe
# D:\Keil_v5\UV4\UV4.exe
KEIL_UV4_PATH = r"C:\Users\yuyunfei\AppData\Local\Keil_v5\UV4\UV4.exe"

# 脚本所在目录
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))

# 编译日志文件路径 (输出到脚本同级目录)
LOG_FILE_PATH = os.path.join(SCRIPT_DIR, "keil_compile.txt")

# 工程列表配置
# path: 工程文件(.uvprojx)的路径，建议使用 os.path.join 组合路径
# target: (可选) 指定编译的 Target 名称，如果不指定则编译默认 Target
PROJECTS = [
    {
        "name": "Bootloader",
        "path": os.path.join(SCRIPT_DIR, "..", "project", "boot", "project.uvprojx"),
    },
    {
        "name": "Application",
        "path": os.path.join(SCRIPT_DIR, "..", "project", "app", "project.uvprojx"),
    }
]

# ===========================================

class Spinner:
    def __init__(self):
        self.stop_event = threading.Event()
        self.thread = threading.Thread(target=self._spin)

    def start(self):
        self.stop_event.clear()
        if not self.thread.is_alive():
            self.thread = threading.Thread(target=self._spin)
            self.thread.start()

    def stop(self):
        self.stop_event.set()
        if self.thread.is_alive():
            self.thread.join()

    def _spin(self):
        chars = itertools.cycle(['-', '/', '|', '\\'])
        while not self.stop_event.is_set():
            sys.stdout.write(next(chars))
            sys.stdout.flush()
            time.sleep(0.1)
            sys.stdout.write('\b')

def compile_project(uv4_path, project_path, index, total):
    """
    编译单个 Keil 工程并返回日志内容
    """
    # 检查 Keil 路径
    if not os.path.exists(uv4_path):
        msg = f"Error: Keil UV4 executable not found at: {uv4_path}\nPlease update 'KEIL_UV4_PATH' in the script.\n"
        print(msg)
        return msg

    # 检查工程文件路径
    if not os.path.exists(project_path):
        msg = f"Error: Project file not found at: {project_path}\n"
        print(msg)
        return msg

    project_name = os.path.basename(project_path)
    print(f"[{index}/{total}] Compiling {project_name}... ", end='', flush=True)
    
    # 临时日志文件名 (Keil 命令行输出)
    temp_log_filename = "build_log_temp.txt"
    
    # 构造命令
    # -b: Build (编译修改过的文件)
    # -r: Rebuild (全编译，如果需要全编译请改为 -r)
    # -j0: Hide GUI (隐藏界面)
    # -o: Output log file (指定输出日志文件)
    cmd = [uv4_path, "-b", project_name, "-j0", "-o", temp_log_filename]
    
    project_dir = os.path.dirname(project_path)
    
    spinner = Spinner()
    spinner.start()
    
    try:
        # 在工程目录下执行命令，这样 -o 生成的日志就在工程目录下
        # capture_output=True 防止 Keil 的任何输出干扰进度条
        result = subprocess.run(cmd, cwd=project_dir, capture_output=True)
        
        # Keil 返回值说明:
        # 0: 0 Errors, 0 Warnings
        # 1: 0 Errors, Warnings
        # 2: Errors
        exit_code = result.returncode
        
        status_msg = ""
        if exit_code == 0:
            status_msg = "Success (0 Errors, 0 Warnings)"
        elif exit_code == 1:
            status_msg = "Success with Warnings"
        elif exit_code >= 2:
            status_msg = "Failed (Errors occurred)"
        else:
            status_msg = f"Unknown status (Exit code: {exit_code})"
            
    except Exception as e:
        status_msg = f"Exception: {str(e)}"
        exit_code = -1
    finally:
        spinner.stop()
        # 覆盖掉 spinner 的字符
        print(" " * 10 + "\r", end='') 
        # 重新打印前缀以便对齐结果
        print(f"[{index}/{total}] Compiling {project_name}... {status_msg}")

    # 读取 Keil 生成的日志文件
    log_content = ""
    full_temp_log_path = os.path.join(project_dir, temp_log_filename)
    
    if os.path.exists(full_temp_log_path):
        try:
            # Keil 日志通常使用系统默认编码 (如 GBK)
            with open(full_temp_log_path, 'r', encoding='gbk', errors='replace') as f:
                log_content = f.read()
            
            # 编译完成后删除临时日志文件，保持目录整洁
            try:
                os.remove(full_temp_log_path)
            except:
                pass
        except Exception as e:
            log_content = f"Failed to read build log file: {str(e)}"
    else:
        log_content = "Build log file was not generated by Keil."

    # Return tuple (success, log_entry)
    is_success = (exit_code <= 1) # 0=OK, 1=Warnings, >=2=Errors
    return is_success, f"Project: {project_path}\nTime: {datetime.datetime.now()}\nStatus: {status_msg}\n\nOutput Log:\n{log_content}\n{'-'*80}\n"

def main():
    print(f"Starting compilation task...")
    print(f"Log file will be saved to: {LOG_FILE_PATH}")
    print("-" * 50)
    
    # 初始化日志文件
    try:
        with open(LOG_FILE_PATH, 'w', encoding='utf-8') as f:
            f.write(f"Compilation Report - {datetime.datetime.now()}\n")
            f.write("="*80 + "\n\n")
    except Exception as e:
        print(f"Error creating log file: {e}")
        sys.exit(1)

    total_projects = len(PROJECTS)
    all_success = True
    
    # 遍历编译所有工程
    for i, proj in enumerate(PROJECTS, 1):
        success, log_entry = compile_project(KEIL_UV4_PATH, proj["path"], i, total_projects)
        
        if not success:
            all_success = False

        # 将结果追加到总日志文件
        try:
            with open(LOG_FILE_PATH, 'a', encoding='utf-8') as f:
                f.write(log_entry)
        except Exception as e:
            print(f"Error writing to log file: {e}")

    print("-" * 50)
    if all_success:
        print(f"All tasks finished successfully. Please check {os.path.basename(LOG_FILE_PATH)} for details.")
        sys.exit(0)
    else:
        print(f"Some tasks failed. Please check {os.path.basename(LOG_FILE_PATH)} for details.")
        sys.exit(1)

if __name__ == "__main__":
    main()
