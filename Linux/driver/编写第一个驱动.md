## 交叉编译设置环境变量

 交叉编译时，一定要**设置工具链版本一致**

```shell
export ARCH=arm
export CROSS_COMPILE=
```

不同的发行版，下载的gcc版本可能不一样

## 编写驱动流程

### 内核下载及编译

下载内核

保证内核编译通过

### 编写驱动程序

照葫芦画瓢编写驱动

编写驱动对应的makefile

```makefile
#指定加载模块的内核路径
KERN_DIR = /home/me/Linux-4.9.88

#$(shell command) 这个结构允许你运行一个shell命令并捕获其输出，将输出作为Makefile变量的值
PWD ?= $(shell KERN_DIR)

all:	
	make -C $(KERN_DIR) M=$(PWD) modules	
clean:
	make -C $(KERN_DIR) M=$(PWD) modules clean
	rm -rf modules.order
	rm -f hello_drv
#将驱动编译为模块，可以被驱动加载。编译后的文件为*.ko
obj-m += hello_drv.o
```

### 加载驱动

#### 动态加载（手动加载）

insmode

rmmod

modprobe

#### 静态加载

将驱动编译进内核

1. 编写Kconfig
2. 修改上一级Kconfig
3. 编译内核
4. 烧录进系统验证

#### 
