<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCUboot交换算法图解</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }
        
        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }
        
        h2 {
            color: #34495e;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-top: 40px;
            font-size: 1.8em;
        }
        
        .algorithm-section {
            margin: 30px 0;
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            border-left: 5px solid #3498db;
        }
        
        .flash-layout {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .slot {
            border: 2px solid #2c3e50;
            border-radius: 8px;
            padding: 15px;
            background: linear-gradient(145deg, #ecf0f1, #bdc3c7);
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            min-width: 120px;
            text-align: center;
        }
        
        .slot-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #2c3e50;
            font-size: 1.1em;
        }
        
        .sector {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9em;
            transition: all 0.3s ease;
        }
        
        .primary { background: #3498db; color: white; }
        .secondary { background: #e74c3c; color: white; }
        .scratch { background: #f39c12; color: white; }
        .empty { background: #95a5a6; color: white; }
        .image0 { background: #2ecc71; color: white; }
        .image1 { background: #9b59b6; color: white; }
        
        .step {
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 8px;
            border-left: 4px solid #e74c3c;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        .step-title {
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 8px;
        }
        
        .arrow {
            text-align: center;
            font-size: 2em;
            color: #e74c3c;
            margin: 10px 0;
        }
        
        .characteristics {
            background: #e8f5e8;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #27ae60;
        }
        
        .characteristics h4 {
            color: #27ae60;
            margin-top: 0;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .comparison-table th {
            background: #34495e;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ecf0f1;
        }
        
        .comparison-table tr:hover {
            background: #f8f9fa;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 30px 0;
        }
        
        .nav-btn {
            padding: 12px 24px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(52, 152, 219, 0.3);
        }
        
        .nav-btn:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: 0 7px 20px rgba(52, 152, 219, 0.4);
        }
        
        .nav-btn.active {
            background: #e74c3c;
            box-shadow: 0 5px 15px rgba(231, 76, 60, 0.3);
        }
        
        .algorithm-view {
            display: none;
        }
        
        .algorithm-view.active {
            display: block;
            animation: fadeIn 0.5s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .step-animation {
            opacity: 0;
            transform: translateX(-20px);
            animation: slideIn 0.6s ease-out forwards;
        }
        
        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>MCUboot交换算法图解</h1>
        
        <div class="nav-buttons">
            <button class="nav-btn active" onclick="showAlgorithm('scratch')">暂存区交换</button>
            <button class="nav-btn" onclick="showAlgorithm('offset')">偏移交换</button>
            <button class="nav-btn" onclick="showAlgorithm('move')">移动交换</button>
            <button class="nav-btn" onclick="showAlgorithm('directxip')">直接执行</button>
            <button class="nav-btn" onclick="showAlgorithm('ramload')">RAM加载</button>
            <button class="nav-btn" onclick="showAlgorithm('comparison')">算法对比</button>
        </div>

        <!-- 暂存区交换算法 -->
        <div id="scratch" class="algorithm-view active">
            <h2>暂存区交换算法（Swap Using Scratch）</h2>
            
            <div class="characteristics">
                <h4>特点：</h4>
                <ul>
                    <li>需要额外的暂存区域</li>
                    <li>最安全的交换方式，支持中断恢复</li>
                    <li>适用于大多数应用场景</li>
                    <li>可能在未来版本中被移除</li>
                </ul>
            </div>

            <div class="step">
                <div class="step-title">初始状态</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image1">镜像1 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">暂存区</div>
                        <div class="sector empty">空</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">步骤1：次插槽扇区3 → 暂存区</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image1">镜像1 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector empty">空</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">暂存区</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">步骤2：主插槽扇区3 → 次插槽扇区3</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector empty">空</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image1">镜像1 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">暂存区</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">步骤3：暂存区 → 主插槽扇区3</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image1">镜像1 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">暂存区</div>
                        <div class="sector empty">空</div>
                    </div>
                </div>
            </div>

            <p><strong>重复以上步骤直到所有扇区交换完成...</strong></p>
        </div>

        <!-- 偏移交换算法 -->
        <div id="offset" class="algorithm-view">
            <h2>偏移交换算法（Swap Using Offset）</h2>
            
            <div class="characteristics">
                <h4>特点：</h4>
                <ul>
                    <li>不需要额外的暂存区域</li>
                    <li>使用次插槽的第一个扇区作为临时空间</li>
                    <li>更新镜像必须从次插槽的第二个扇区开始</li>
                    <li>内存使用更高效</li>
                </ul>
            </div>

            <div class="step">
                <div class="step-title">初始状态（更新镜像从扇区2开始）</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector empty">空（临时空间）</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">步骤1：主插槽扇区N → 次插槽扇区N</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector empty">空</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">步骤2：次插槽扇区N+1 → 主插槽扇区N</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector empty">空</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <p><strong>继续这个过程直到所有扇区交换完成</strong></p>
        </div>

        <!-- 移动交换算法 -->
        <div id="move" class="algorithm-view">
            <h2>移动交换算法（Swap Using Move）</h2>
            
            <div class="characteristics">
                <h4>特点：</h4>
                <ul>
                    <li>使用主插槽的最高扇区作为临时空间</li>
                    <li>主插槽比次插槽大一个扇区</li>
                    <li>首先将主插槽所有扇区上移一个位置</li>
                    <li>偏移算法是首选替代方案</li>
                </ul>
            </div>

            <div class="step">
                <div class="step-title">初始状态</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽（N+1扇区）</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                        <div class="sector empty">空（临时空间）</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽（N扇区）</div>
                        <div class="sector image1">镜像1 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">步骤1：主插槽所有扇区上移一位</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector empty">空</div>
                        <div class="sector image0">镜像0 扇区1</div>
                        <div class="sector image0">镜像0 扇区2</div>
                        <div class="sector image0">镜像0 扇区3</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image1">镜像1 扇区1</div>
                        <div class="sector image1">镜像1 扇区2</div>
                        <div class="sector image1">镜像1 扇区3</div>
                    </div>
                </div>
            </div>

            <div class="arrow">↓</div>

            <div class="step">
                <div class="step-title">然后按正常交换流程进行</div>
                <p>从这一步开始，算法类似于暂存区交换，但使用主插槽的顶部扇区作为临时存储。</p>
            </div>
        </div>

        <!-- 直接执行模式 -->
        <div id="directxip" class="algorithm-view">
            <h2>直接执行模式（Direct-XIP）</h2>
            
            <div class="characteristics">
                <h4>特点：</h4>
                <ul>
                    <li>不进行镜像交换</li>
                    <li>可以直接从任一插槽执行镜像</li>
                    <li>根据版本号选择最新镜像</li>
                    <li>不支持镜像加密</li>
                    <li>镜像必须为对应插槽构建</li>
                </ul>
            </div>

            <div class="step">
                <div class="step-title">镜像选择过程</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽</div>
                        <div class="sector image0">镜像 v1.0</div>
                        <div class="sector image0">有效</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽</div>
                        <div class="sector image1">镜像 v1.2</div>
                        <div class="sector image1">有效</div>
                    </div>
                </div>
                <p style="text-align: center; margin-top: 15px;">
                    <strong>选择版本更高的镜像（v1.2）从次插槽直接执行</strong>
                </p>
            </div>

            <div class="step">
                <div class="step-title">支持回滚机制</div>
                <p>如果新镜像启动后没有标记为"OK"，下次启动时会选择另一个插槽的镜像。</p>
            </div>
        </div>

        <!-- RAM加载模式 -->
        <div id="ramload" class="algorithm-view">
            <h2>RAM加载模式（RAM Load）</h2>
            
            <div class="characteristics">
                <h4>特点：</h4>
                <ul>
                    <li>插槽相等，类似直接执行模式</li>
                    <li>选择最新镜像但复制到RAM执行</li>
                    <li>适用于没有内部flash但有足够RAM的SoC</li>
                    <li>提供更高的执行速度和安全性</li>
                </ul>
            </div>

            <div class="step">
                <div class="step-title">镜像选择和加载过程</div>
                <div class="flash-layout">
                    <div class="slot">
                        <div class="slot-title">主插槽（Flash）</div>
                        <div class="sector image0">镜像 v1.0</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">次插槽（Flash）</div>
                        <div class="sector image1">镜像 v1.2</div>
                    </div>
                    <div class="slot">
                        <div class="slot-title">RAM</div>
                        <div class="sector image1">复制的镜像 v1.2</div>
                        <div style="text-align: center; margin-top: 10px; color: #e74c3c;">
                            <strong>执行位置</strong>
                        </div>
                    </div>
                </div>
            </div>

            <div class="step">
                <div class="step-title">处理流程</div>
                <ol>
                    <li>比较两个插槽中的镜像版本号</li>
                    <li>选择版本更高的镜像（v1.2）</li>
                    <li>将选中的镜像复制到RAM中指定地址</li>
                    <li>验证RAM中的镜像完整性</li>
                    <li>从RAM执行镜像</li>
                </ol>
            </div>
        </div>

        <!-- 算法对比 -->
        <div id="comparison" class="algorithm-view">
            <h2>算法对比</h2>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>算法</th>
                        <th>额外存储需求</th>
                        <th>镜像交换</th>
                        <th>加密支持</th>
                        <th>复杂度</th>
                        <th>适用场景</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>暂存区交换</strong></td>
                        <td>需要暂存区</td>
                        <td>是</td>
                        <td>完全支持</td>
                        <td>高</td>
                        <td>最安全，支持所有功能</td>
                    </tr>
                    <tr>
                        <td><strong>偏移交换</strong></td>
                        <td>次插槽多一个扇区</td>
                        <td>是</td>
                        <td>完全支持</td>
                        <td>中</td>
                        <td>推荐的无暂存区方案</td>
                    </tr>
                    <tr>
                        <td><strong>移动交换</strong></td>
                        <td>主插槽多一个扇区</td>
                        <td>是</td>
                        <td>完全支持</td>
                        <td>中</td>
                        <td>已有产品的兼容选择</td>
                    </tr>
                    <tr>
                        <td><strong>直接执行</strong></td>
                        <td>无</td>
                        <td>否</td>
                        <td>不支持</td>
                        <td>低</td>
                        <td>简单升级，无加密需求</td>
                    </tr>
                    <tr>
                        <td><strong>RAM加载</strong></td>
                        <td>足够的RAM</td>
                        <td>否</td>
                        <td>支持</td>
                        <td>低</td>
                        <td>外部存储，内部RAM执行</td>
                    </tr>
                </tbody>
            </table>

            <div class="characteristics">
                <h4>选择建议：</h4>
                <ul>
                    <li><strong>新项目</strong>：推荐偏移交换算法</li>
                    <li><strong>需要加密</strong>：避免直接执行模式</li>
                    <li><strong>RAM充足</strong>：考虑RAM加载模式</li>
                    <li><strong>资源受限</strong>：直接执行模式最简单</li>
                    <li><strong>最大安全性</strong>：暂存区交换（虽然可能被弃用）</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        function showAlgorithm(algorithmId) {
            // 隐藏所有算法视图
            const views = document.querySelectorAll('.algorithm-view');
            views.forEach(view => view.classList.remove('active'));
            
            // 移除所有按钮的active类
            const buttons = document.querySelectorAll('.nav-btn');
            buttons.forEach(btn => btn.classList.remove('active'));
            
            // 显示选中的算法视图
            document.getElementById(algorithmId).classList.add('active');
            
            // 高亮选中的按钮
            event.target.classList.add('active');
            
            // 添加动画效果
            const steps = document.querySelectorAll(`#${algorithmId} .step`);
            steps.forEach((step, index) => {
                step.style.animationDelay = `${index * 0.1}s`;
                step.classList.add('step-animation');
            });
        }

        // 初始化动画
        document.addEventListener('DOMContentLoaded', function() {
            const initialSteps = document.querySelectorAll('#scratch .step');
            initialSteps.forEach((step, index) => {
                step.style.animationDelay = `${index * 0.1}s`;
                step.classList.add('step-animation');
            });
        });
    </script>
</body>
</html>